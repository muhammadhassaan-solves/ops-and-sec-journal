Request Size Limitation: Large API Payloads Failing
Date: 22/09/2025

Problem:
Developers reported that API requests with large payloads (such as file uploads) were failing. The error returned was:
413 Request Entity Too Large
In short, the server was rejecting large requests before they could reach the application backend.

Root Cause:
By default, Nginx limits the maximum allowed request body size to 1 MB.
Any request exceeding this limit was blocked by Nginx, preventing it from being processed by the application.

Solution:
We increased the allowed request size and timeout values in the Nginx configuration.
Under the server block, the following directives were added:
client_max_body_size 200M;
client_body_timeout 900;

After updating the configuration, the changes were tested and applied:
nginx -t
systemctl reload nginx

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Github Actions CI/CD Automation: RAG WebUI App Deployment
Date: 24/09/2025

Problem:
Needed a fully automated CI/CD pipeline to:
Build frontend and backend on push to master.
Create and push Docker image to Docker Hub.
Deploy container to production server.

Root Cause of Failure:
Node.js memory limit: Frontend build required more heap than default.
Peer dependency conflicts: npm ci failed due to unresolved peer deps.

Solution:
Increase Node.js Heap in Docker Build
RUN npm install --legacy-peer-deps
ENV NODE_OPTIONS="--max-old-space-size=8192"
RUN npm run pyodide:fetch && npm run build

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CORS Header Configuration Fix
Date: 1/10/2025

Problem:
Browsers were blocking API requests due to missing or undefined CORS headers.
Error cause:
Access-Control-Allow-Origin: undefined
The backend server attempted to set Access-Control-Allow-Origin, but the value was missing. As a result, browsers rejected the response.

Root Cause:
The .env configuration did not include the allowed frontend domain in the origin list.
When the request domain wasn’t defined, the CORS middleware sent an empty header, triggering browser rejection.

Solution:
Added the required frontend domain to environment variables via Kubernetes secrets.
Ensured Access-Control-Allow-Origin is dynamically set based on allowed origins from environment variables.
Recommended switching to a list-based configuration (e.g., comma-separated domains) instead of hardcoding multiple variables.

DevOps Handling Guide:
If this error reoccurs:
Ask the developer which domain is making the request.
Compare it with the allowed origins in .env.

If missing, update the environment configuration.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Deployment Issue: Updated Code Not Reflecting on Website
Date: 22/10/2025

Problem:
The developer updated the code, and the GitHub Actions pipeline completed successfully, but the changes were not reflecting on the website.

Root Cause:
When I attempted to manually pull the updated Docker image (instead of relying on the CI/CD pipeline), the image failed to download completely — one of the layers wasn’t pulling successfully. Upon further investigation, I discovered that the instance’s disk space was completely full, which prevented the image from being pulled properly.

Solution:
I ran the following command to clean up unused Docker data and free up space:
docker system prune -f --volumes

This freed up approximately 42 GB of disk space. Afterward, developer was able to pull the image successfully, and the website began reflecting the latest changes.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Application Hang Issue: Node.js Container Not Restarting
Date: 24/10/2025

Problem:
The Node.js application occasionally became unresponsive when an unhandled error occurred. Although the process was stuck, the container itself continued running, requiring the development team to manually restart it.

Root Cause:
The Dockerfile used by the development team was configured to run the application using nodemon. When an unhandled exception occurred, nodemon did not terminate the container—it kept it in a running state. As a result, neither Docker nor Kubernetes detected the failure, preventing an automatic restart.

Solution:
We updated the setup to use node instead of nodemon in the Dockerfile, ensuring that the container exits when an unhandled error occurs.
Additionally, we added a restart policy in the Docker Compose file to automatically restart containers when they fail.

In the Kubernetes environment, this change aligned perfectly with Kubernetes’ native restart mechanism. When the Node.js process exits, the Pod automatically restarts, ensuring continuous availability.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

